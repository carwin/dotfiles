#+title: Org-Mode Workflow
#+author: Carwin Young
#+property: header-args:emacs-lisp :tangle (concat user-emacs-directory "cy-workflow.el") :mkdirp yes

This file contains the description and configuration of the
productivity workflow I plan on using with Org.

* Principles

1. Don't look at Org files to find the next task, use the agenda.
2. Ensure sufficient metadata on tasks for effective filtering.
3. Keep a daily log of work being done.

* File Paths

The location where my Notes folder lives. There's a function here in
case I need to adjust my Notes directory based on machine.

#+begin_src emacs-lisp
(setq org-directory "~/Notes")

(setq org-agenda-files `(,org-directory))

(defun cy/org-path (path)
  (expand-file-name path org-directory))

(setq org-default-notes-file (cy/org-path "Inbox.org"))
#+end_src

* Workflow States

I try to keep my set of workflow states simple so that I can filter on them easily.

- =TODO= - A task that should be done at some point.
- =NEXT= - This task should be done next (in the Getting Things Done sense).
- =BACK= - A task in the backlog to be done some day but not now.
- =WAIT= - Waiting for someone else to be actionable again
- =DONE= - It's done!
- CANCELLED - Used almost exclusively for events, but also handy for things I'd like to remember were once planned.

I also make sure to set them up in the order I want `org-sort-entries'
to sort them in when I use the o option invoking that command.

#+begin_src emacs-lisp
(setq org-todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    (sequence "|" "WAIT(w)" "BACK(b)" "CANCELLED(c!)")))

;; @todo: org-todo-keyword-faces
(setq org-todo-keyword-faces
'(("NEXT" . (:foreground "orange red" :weight bold))
  ("TODO" . (:foreground "medium sea green" :weight bold))
  ("WAIT" . (:foreground "HotPink2" :weight bold))
  ("BACK" . (:foreground "MediumPurple3" :weight bold))))
(setq org-global-properties
    '(("Effort_ALL". "0 0:10 0:30 1:00 2:00 3:00 4:00")))
#+end_src

* Tags

Tags are used to filter all tasks to find anything actionable in a
particular context. I use the @home and @work tags for explicit
contexts and then the rest are used for filtering tasks for agenda
views.

- =followup= - Someone is waiting on me to follow up on this task, it should be prioritized above others.
- =batch= - The task can be batched with others (low effort)

#+begin_src emacs-lisp
;; Configure common tags
(setq org-tag-alist
  '((:startgroup)
   ; Put mutually exclusive tags here
   ("@home" . ?h)
   ("@work" . ?w)
   (:endgroup)
   ("batch" . ?b)
   ("recurring" . ?r)
   ("followup" . ?f)))
#+end_src

* Asana

#+begin_src emacs-lisp
;; (setenv "ASANA_TOKEN" (password-store-get "asana/work-pat"))
;; (setq asana-token (password-store-get "asana/work-pat"))
;; ;; (use-package emacs-asana
;; ;;   :straight (emacs-asana :type git :host github :repo "lmartel/emacs-asana")
;; ;;   :custom (global-asana-mode 1)
;; ;;   :config (setq asana-keymap-prefix "C-c C-9"))
;; (straight-use-package
;;  '(emacs-asana :type git :host github :repo "lmartel/emacs-asana"))
;; ;; asana-tasks-org-file (concat (cy/system-settings-get 'user/notes) "Asana.org")))
;; (setq global-asana-mode 1)
#+end_src
* GTasks Integration

Integration with Google Tasks works pretty well thanks to the
org-gtasks package (which lives on GitHub somewhere), but I don't
really have a use for it right now. Config kept here for posterity.

#+begin_src emacs-lisp
(use-package org-gtasks
  :straight (org-gtasks :type git :host github :repo "JulienMasson/org-gtasks")
  :after org
  ;; :load-path "~/.emacs.d/org-gtasks"
  :config
  (org-gtasks-register-account :name "Work"
                               :directory "~/Notes/gtasks/work"
                               :client-id (password-store-get "org-gtasks/gtasks-client-id--snyk")
                               :client-secret (password-store-get "org-gtasks/gtasks-client-secret--snyk"))
  (org-gtasks-register-account :name "Carwin Young"
                               :directory "~/Notes/gtasks/home"
                               :client-id (password-store-get "org-gtasks/gtasks-client-id")
                               :client-secret (password-store-get "org-gtasks/gtasks-client-secret")))
;; (add-hook 'org-capture-after-finalize-hook (org-gtasks-push-tasks "Work"))
(defun cy/reclaim-tasks-post-capture ()
  (interactive)
  (when-let* ((file (concat (cy/system-settings-get 'user/home) "Notes/gtasks/work/🗓 Reclaim.org"))
              (title (file-name-base file))
              (dir (file-name-directory file))
              (account (org-gtasks-find-account-by-dir dir)))
    (if-let* ((tasklists (org-gtasks-tasklists account))
              (tasklist (org-gtasks-find-tasklist tasklists title)))
        (org-gtasks-push-tasklists account (list tasklist)
				   (apply-partially #'org-gtasks-fetch-tasks
						    account tasklist))
      (when (yes-or-no-p "No tasklist found, do you want pull this account ?")
        (org-gtasks-check-token account)
        (org-gtasks-pull account "ALL"))))
  (message "Finished running cy/reclaim-tasks-post-capture..."))

(add-hook 'org-capture-after-finalize-hook 'cy/reclaim-tasks-post-capture)
#+end_src

* Agendas

#+begin_src emacs-lisp
(defun cy/refile-when-tagged-work ()
  (interactive)
  (let* ((tags (org-get-tags))
         (org-refile-targets `(,@(seq-map (lambda (tag)
                                            (cons 'org-agenda-files (cons :tag tag)))
                                          tags))))
    (call-interactively 'org-refile)))
#+end_src

#+begin_src emacs-lisp
(setq org-agenda-window-setup 'current-window)
(setq org-agenda-span 'day)
(setq org-agenda-start-with-log-mode t)
(setq org-agenda-files (list (cy/org-path "Inbox.org")
                             ;; (cy/org-path "Habits.org")
                             ;; (cy/org-path "Roam-v2/Journal/")
                             ;; (cy/org-path "gtasks/work/🗓 Reclaim.org")
                             (cy/org-path "Calendar/Personal.org")))
(setq org-agenda-custom-commands
      `(("d" "Dashboard"
         ((agenda ""
                  ((org-deadline-warning-days 7)
                   (org-agenda-files org-agenda-files)))
          (tags-todo "+PRIORITY=\"A\""
                     ((org-agenda-overriding-header "High Priority")))
          (tags-todo "+followup" ((org-agenda-overriding-header "Needs Follow Up")))
          (todo "NEXT"
                ((org-agenda-overriding-header "Next Actions")))
          (todo "TODO"
                ((org-agenda-overriding-header "Unprocessed Inbox Tasks")
                 (org-agenda-files '(,(cy/org-path "Inbox.org")))
                 (org-agenda-text-search-extra-files nil)))))

        ("t" "Custom Timeline"
         ((todo "TODO"
                ((org-agenda-overriding-header "=== TODO tasks without a scheduled date=== ")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                 (org-agenda-prefix-format '((todo . " %1c "))))
                (agenda ""
                        ((org-agenda-overriding-header "=== Scheduled tasks ===")
                         (org-agenda-span 22)
                         (org-agenda-files org-agenda-files)
                         (org-agenda-prefix-format '((agenda . " %1c %?-12t% s"))))))))

        ("n" "Next Tasks"
         ((agenda "" ((org-deadline-warning-days 7)))
          (todo "NEXT"
                ((org-agenda-overriding-header "Next Tasks")))))

        ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
         ((org-agenda-overriding-header "Low Effort Tasks")
          (org-agenda-max-todos 20)
          (org-agenda-files org-agenda-files)))))
#+end_src

* Recent Files

=dashboard= is the first thing the user (me) sees upon starting Emacs,
it is currently configured to show the upcoming agenda as well as the
most recent files the user has visited using =recentf-mode=. Because the
dashboard needs to keep the agenda files open, that list of recent
files gets filled with agenda files at all times, which isn't very
useful.

This block tells =recentf-mode= to ignore the agenda files.

#+begin_src emacs-lisp
(setq recentf-exclude `("/tmp/"
                        "/ssh:"
                        "/sudo:"
                        "recentf$"
                        ,(expand-file-name (concat (cy/system-settings-get 'user/notes) "Inbox.org"))
                        ,(expand-file-name (concat (cy/system-settings-get 'user/notes) "Calendar/.*org$"))
                        ,(expand-file-name (concat (cy/system-settings-get 'user/notes) "Habits.org"))))
#+end_src

* Habits

Though =org-habits= is no longer in use, it may be useful to keep the
configuration around in case it becomes useful again.

#+begin_src emacs-lisp
;; (setq org-habit-show-habits-only-for-today nil
;;       org-habit-graph-column
;;       org-habit-preceding-days 4
;;       org-habit-following-days 4)
#+end_src

* Contacts

Handle contacts via Org-mode. This isn't a wonderful solution, because
it doesn't seem to pull from =mu4e=, although it =mu4e= will read from it.

#+begin_src emacs-lisp
(use-package org-contacts
  :straight org-contrib
  :after org-contrib
  :custom (org-contacts-files '("~/Notes/Contacts.org")))
#+end_src

The =org-contacts= package doesn't ship with much in the way of
templates, so I create a few below:

#+begin_src emacs-lisp
(defun cy/org-contacts-template-tel (&optional return-value)
  return-value
  (concat "%^{Phone number (111-222-3333)}"))
(defun cy/org-contacts-template-addr (&optional return-value)
  return-value
  (concat "%^{Address (18455 S Figueroa St, Gardena CA 90248)}"))
#+end_src

* Capture Templates

Basic workflow capture templates.

@TODO: Split this up and document everything.

#+begin_src emacs-lisp
(defun cy/on-org-capture ()
  ;; Don't show the confirmation header text
  (setq header-line-format nil)

  ;; Control how some buffers are handled
  (let ((template (org-capture-get :key t)))
    (pcase template
      ("jj" (delete-other-windows)))))

(defun cy/get-work-peer-names-from-files ()
  (setq work-people-file-list (directory-files (cy/org-path (concat "Work/People/")) nil directory-files-no-dot-files-regexp))
  (setq work-list '())
  (dolist (element work-people-file-list)
    (let (name)
       (setq name-no-dash (replace-regexp-in-string "-" " " element))
       (setq name (replace-regexp-in-string ".org" "" name-no-dash))
       (add-to-list 'work-list name))
    )
   work-list
  )

(defun cy/org-work-person-log ()
  (let (person-name)
    (setq choice (completing-read "choose: " (cy/get-work-peer-names-from-files) nil nil nil))
    ;; (print person-name)
    (cy/org-path (concat "Work/People/" (concat (replace-regexp-in-string " " "-" (capitalize choice)) ".org")))))

(defun cy/duration-to-seconds (duration)
  "Return number of seconds of DURATION string."
  (message "received duration: %s" duration)
  (let ((seconds 0)
        (unit 1))
    (dolist (n (nreverse (mapcar #'string-to-number (split-string duration ":"))))
      (setq seconds (+ seconds (* n unit)))
      (setq unit (* unit 60))
      (message "eh?: %s" seconds)
      (message "oh?: %s" unit)
)
    seconds))

(cl-assert (= (cy/duration-to-seconds "02:30:00") (+ (* 2 60 60) (* 60 30))))

(defun cy/capture-to-reclaim ()
  (let ((key (plist-get org-capture-plist :key))
        (buffer (plist-get org-capture-plist :buffer))
        (begincap (plist-get org-capture-plist :begin-marker))
        (endcap (plist-get org-capture-plist :end-marker)))
    (let ((contents (with-current-buffer (plist-get org-capture-plist :buffer) (buffer-substring-no-properties begincap endcap))))
      (let ((heading (org-get-heading t t t t))
            (effort (format-seconds "%mm" (with-current-buffer buffer (cy/duration-to-seconds (concat (org-entry-get endcap "Effort") ":00"))))))
          (if org-note-abort
              (message "Template with %s and description “%s” aborted" key desc)
            (with-current-buffer buffer (write-region (format "%s" (concat "\n* TODO " (concat heading (concat " (for " (concat effort ")"))))) nil "~/Notes/gtasks/work/🗓 Reclaim.org" 'append)))))))


;; (write-region (format "%s" (with-current-buffer buffer (concat "\n* TODO " (concat heading (concat " (for " (concat effort ")")))))) nil "~/Notes/gtasks/work/🗓 Reclaim.org" 'append))))))
;; (write-region (format "%s" (with-current-buffer buffer (buffer-substring-no-properties begincap endcap))) nil "~/Notes/gtasks/work/🗓 Reclaim.org" 'append)

(add-hook 'org-capture-before-finalize-hook 'cy/capture-to-reclaim)
(add-hook 'org-capture-mode-hook 'cy/on-org-capture)

(setq org-capture-templates
  `(
    ("t" "Task" entry (file ,(cy/org-path "Inbox.org"))
         "* TODO %?\n %U\n %i" :empty-lines 1)
    ("m" "Task [mail]" entry (file ,(cy/org-path "Inbox.org"))
         ,(concat "* TODO Process \"%a\" %?\n"
                  "/Entered on/ %U"))
    ("c" "Contacts" entry (file ,(cy/org-path "Contacts.org"))
         "* %(org-contacts-template-name)
         :PROPERTIES:
         :EMAIL: %(org-contacts-template-email)
         :PHONE: %(cy/org-contacts-template-tel)
         :ADDRESS: %(cy/org-contacts-template-addr)
         :BIRTHDAY:
         :END:")
    ("T" "Team Log" item (file+headline cy/org-work-person-log "Log")
         "- %U %?"
         :lines-before 0
         :lines-after 0
         :unnarrowed t
         :prepend t)))
#+end_src

* Provide

Provide =cy-workflow= so it can be required by =./Emacs.org=.

#+begin_src emacs-lisp
(provide 'cy-workflow)
#+end_src
